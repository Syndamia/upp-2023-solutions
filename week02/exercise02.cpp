#include <iostream>

int main() {
	unsigned int n;
	std::cin >> n;
	// Чрез побитовото и (&) можем лесно да направим "филтър", ако бита в дясно е единица приемаме бита в ляво, иначе връщаме 0.
	// От неговата дефиниция, ако имаме някакъв входен бит X, тогава X & 1 винаги ще връща X
	//   С примери: ако X=0, тогава 0 & 1 = 0; ако X=1, тогава 1 & 1 = 1
	// Обаче X & 0 винаги връща0
	//   С примери: ако X=0, то 0 & 0 = 0; ако X = 1, то 1 & 0 = 0
	// Понеже не правим "сметкаджийска" операция, а повече използваме & за филтър, общоприето е да наричаме бита след & "маска".
	// 
	// Тоест, да вземем най-десните 6 бита, означава да занулим останалите, тоест ще ползваме &, като в нашата маска
	// трябва при най-десните 6 бита да са 1, докато останалите да са 0
	//
	// Най-десните 6 бита съответстват на 2^5, 2^4, 2^3, 2^2, 2^1 и 2^0
	// Тоест, търсената маска е сумата на тези степени, което като го сметнем, излиза 31
	// Има и по-лесен начин да го изчислим, като забележим, че тази сума е равна на 2^6 - 1
	std::cout << (n & 31) << std::endl;
}
